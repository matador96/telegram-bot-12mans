const {
  getCurrentMatch,
  getAllPlayers,
  getLastFinishedMatch,
  getCountOfFinishedMatches,
} = require("./../core/db");
const { isAdmin } = require("./../consts/admins");
const messages = require("./../consts/messages");
const { createMatchMessage, createMatchPendingMessage } = require("./main");
const { closeCtx } = require("./../helpers/main");

const HelpButton = { text: "‚ùì –ü–æ–º–æ—â—å", callback_data: "help" };
const StatsButton = { text: "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–æ–≤", callback_data: "stats" };
const CurrentMatchButton = {
  text: "‚öΩÔ∏è –¢–µ–∫—É—â–∏–π –º–∞—Ç—á",
  callback_data: "current",
};

const LastMatchButton = {
  text: "‚öΩÔ∏è –ü–æ—Å–ª–µ–¥–Ω–∏–π –º–∞—Ç—á",
  callback_data: "last",
};

const isPrivate = (bot, ctx, obj) => {
  if (ctx.chat.type === "private") {
    const chatId = obj.chat.id;

    if (isAdmin(obj.message.from.id)) {
      // bot.telegram.sendMessage(chatId, messages.adminMessage, {
      //   parse_mode: "markdown",
      // });
    } else {
      bot.telegram.sendMessage(
        chatId,
        `${messages.notInPrivate}, –∞ —Ç–∞–∫ —Ç–≤–æ–π tg id: ${obj.message.from.id}`,
        {
          parse_mode: "html",
        }
      );
    }

    return true;
  } else {
    return false;
  }
};

const handleHelp = (bot) => async (ctx, obj, fromObj, chatId) => {
  if (isPrivate(bot, ctx, obj)) {
    return;
  }

  const userInfo = fromObj;

  const text = `${messages.help} \n üéÆ –ó–∞–ø—Ä–æ—Å–∏–ª: [${
    userInfo?.first_name || userInfo?.last_name || userInfo?.id
  }](tg://user?id=${userInfo.id}) üïπÔ∏è`;

  await bot.telegram.sendMessage(chatId, text, {
    parse_mode: "Markdown",
    reply_markup: {
      inline_keyboard: [[{ text: "MENU ‚ò∞", callback_data: "start" }]],
    },
  });
};

const handleStats = (bot) => async (ctx, obj, fromObj, chatId) => {
  if (isPrivate(bot, ctx, obj)) {
    return;
  }

  const userInfo = fromObj;

  const countOfMatches = await getCountOfFinishedMatches();
  const players = await getAllPlayers();

  let postText = `üèÜ *–†–µ–π—Ç–∏–Ω–≥ –∏–≥—Ä–æ–∫–æ–≤, –≤—Å–µ–≥–æ –º–∞—Ç—á–µ–π: ${countOfMatches} *\n
    –ò–≥—Ä–æ–∫ | –û—á–∫–æ–≤ / –ü–æ–±–µ–¥ / –ú–∞—Ç—á–µ–π / –í–∏–Ω—Ä–µ–π—Ç
    ------------------------------------\n`;

  players.forEach((user, index) => {
    let emoji = "";

    if (index === 0) {
      emoji = "ü•á";
    }

    if (index === 1) {
      emoji = "ü•à";
    }

    if (index === 2) {
      emoji = "ü•â";
    }

    postText += `${index + 1}. ${emoji} ${user?.fullName} | ${
      user?.rating || 0
    } / ${user.winCount || 0} / ${user.matchCount || 0} / ${
      user.winRate ? `${user.winRate}%` : `0%`
    } \n`;
  });

  postText += `\nüéÆ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–ø—Ä–æ—Å–∏–ª: [${
    userInfo?.first_name || userInfo?.last_name || userInfo?.id
  }](tg://user?id=${userInfo.id}) üïπÔ∏è`;

  await bot.telegram.sendMessage(chatId, postText, {
    parse_mode: "Markdown",
    reply_markup: {
      inline_keyboard: [[{ text: "MENU ‚ò∞", callback_data: "start" }]],
    },
  });
};

const handleStart = (bot) => async (ctx, obj, fromObj, chatId) => {
  if (isPrivate(bot, ctx, obj)) {
    return;
  }

  const userInfo = fromObj;

  await bot.telegram.sendMessage(
    chatId,
    `${messages.welcomeTelegramBot} ID –∫–∞–Ω–∞–ª–∞ ${chatId}
\nüéÆ –ú–µ–Ω—é –∑–∞–ø—Ä–æ—Å–∏–ª: [${
      userInfo?.first_name || userInfo?.last_name || userInfo?.id
    }](tg://user?id=${userInfo.id}) üïπÔ∏è
`,
    {
      parse_mode: "markdown",
      reply_markup: {
        inline_keyboard: [
          [CurrentMatchButton],
          [LastMatchButton],
          [StatsButton],
          [HelpButton],
        ],
      },
    }
  );
};

const handleCurrentMatch =
  (bot) => async (ctx, obj, fromObj, chatId, messageType) => {
    if (isPrivate(bot, ctx, obj)) {
      return;
    }

    const currentMatch = await getCurrentMatch();
    const userInfo = fromObj;

    if (!currentMatch) {
      if (messageType === "text") {
        await bot.telegram.sendMessage(
          chatId,
          `[${
            userInfo?.first_name || userInfo?.last_name || userInfo?.id
          }](tg://user?id=${userInfo.id}), —Å–µ–π—á–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π`,
          {
            parse_mode: "markdown",
          }
        );
      } else {
        await closeCtx(ctx, "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π", false);
      }

      return;
    }

    await createMatchMessage(ctx, currentMatch.id);
  };

const handleLastMatch =
  (bot) => async (ctx, obj, fromObj, chatId, messageType) => {
    if (isPrivate(bot, ctx, obj)) {
      return;
    }

    const match = await getLastFinishedMatch();
    const userInfo = fromObj;

    if (!match) {
      if (messageType === "text") {
        await bot.telegram.sendMessage(
          chatId,
          `[${
            userInfo?.first_name || userInfo?.last_name || userInfo?.id
          }](tg://user?id=${userInfo.id}), —Å–µ–π—á–∞—Å –Ω–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π`,
          {
            parse_mode: "markdown",
          }
        );
      } else {
        await closeCtx(ctx, "–ù–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π", false);
      }

      return;
    }

    await createMatchPendingMessage(ctx, match.id);
  };

module.exports = {
  handleHelp,
  handleStats,
  handleStart,
  isPrivate,
  handleCurrentMatch,
  handleLastMatch,
};
